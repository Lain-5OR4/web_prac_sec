# Webアプリケーション認証講義
## 1時間で学ぶ認証の基礎とセキュリティ

---

## 目次
1. [認証とは](#認証とは)
2. [ステートレスとステートフルの基礎](#ステートレスとステートフルの基礎)
3. [認証の種類](#認証の種類)
4. [実装方法](#実装方法)
5. [セキュリティ脆弱性](#セキュリティ脆弱性)
6. [ベストプラクティス](#ベストプラクティス)
7. [実演デモ](#実演デモ)

---

## 認証とは

### 定義
- **Authentication（認証）**: ユーザーが誰であるかを確認するプロセス
- **Authorization（認可）**: 認証されたユーザーが何をできるかを決定するプロセス

### 認証の必要性
- ユーザーの身元確認
- 不正アクセスの防止
- 個人情報の保護
- システムの完全性維持

---

## セッションとは何か？

### セッションの基本概念
**セッション（Session）** = **一連のやり取りの期間**
- Webブラウザがサーバーと「つながっている状態」
- ログインから**ログアウトまでの期間**
- **一時的な記憶領域**のようなもの

### 日常生活での例え
#### 🏪 お店での買い物
```
1. お店に入る（ログイン）
2. 店員があなたを覚えている（セッション）
3. 複数の商品を選ぶ（複数のページを見る）
4. 店員「先ほどの○○さんですね」（認識される）
5. お会計して退店（ログアウト）
```

#### 📞 電話での会話
```
1. 電話をかける（接続開始）
2. 相手が「もしもし」（セッション開始）
3. 会話を続ける（データのやり取り）
4. 「それでは失礼します」（セッション終了）
5. 電話を切る（接続終了）
```

### Webにおけるセッション

#### なぜセッションが必要？
**HTTPは「忘れっぽい」プロトコル**
- 1回1回のリクエストは**独立**
- 前回の訪問を覚えていない
- 「あなたが誰か」を毎回忘れてしまう

```
問題のある状況：
ブラウザ「ログインページを表示して」
サーバー「はい、どうぞ」

ブラウザ「ログインしました！」  
サーバー「わかりました」

ブラウザ「マイページを表示して」
サーバー「あなた誰ですか？」← 忘れている！
```

#### セッションで解決
```
解決後の状況：
ブラウザ「ログインページを表示して」
サーバー「はい、どうぞ」

ブラウザ「ログインしました！」  
サーバー「わかりました。セッションID: ABC123 を発行」

ブラウザ「マイページを表示して（SessionID: ABC123）」
サーバー「ABC123のユーザーですね！マイページをどうぞ」
```

### セッションの実装方法

#### 1. セッションIDの生成
```
ユーザーがログイン
↓
サーバーがランダムな文字列を生成
例: "a1b2c3d4e5f6g7h8i9j0"
```

#### 2. セッションIDの送信方法

**🍪 Cookie（最も一般的）**
```
HTTP Response:
Set-Cookie: sessionId=a1b2c3d4e5f6g7h8i9j0; HttpOnly; Secure
```

**📧 URLパラメータ**
```
https://example.com/mypage?sessionId=a1b2c3d4e5f6g7h8i9j0
```

**📝 リクエストヘッダー**
```
X-Session-ID: a1b2c3d4e5f6g7h8i9j0
```

#### 3. セッションデータの保存場所

**💾 サーバーメモリ**
```
sessions = {
  "a1b2c3d4e5f6g7h8i9j0": {
    userId: "user123",
    loginTime: "2024-01-01 10:00",
    lastAccess: "2024-01-01 10:30"
  }
}
```

**🗄️ データベース**
```sql
CREATE TABLE sessions (
  session_id VARCHAR(50),
  user_id VARCHAR(20),
  login_time TIMESTAMP,
  last_access TIMESTAMP
);
```

**⚡ Redis（高速キャッシュ）**
```
SET session:a1b2c3d4e5f6g7h8i9j0 "user123" EX 3600
```

### セッションのライフサイクル

#### 1. セッション開始
```
1. ユーザーがログイン
2. 認証成功
3. セッションID生成
4. クライアントに送信
```

#### 2. セッション継続
```
1. クライアントがセッションID付きでリクエスト
2. サーバーがセッションID確認
3. 有効なら処理実行
4. 最終アクセス時刻更新
```

#### 3. セッション終了
**明示的終了（ログアウト）**
```
1. ユーザーがログアウトボタンクリック
2. サーバーがセッションデータ削除
3. クライアントのCookie削除
```

**自動終了（タイムアウト）**
```
1. 一定時間（例：30分）アクセスなし
2. サーバーが自動的にセッション削除
3. 次回アクセス時「再ログインしてください」
```

### セッションのメリット・デメリット

#### ✅ メリット
- **実装が簡単**: ライブラリが豊富
- **セキュリティ**: サーバー側で完全制御
- **軽量通信**: セッションIDのみ送信
- **即座の制御**: ログアウト・権限変更が即座に反映

#### ❌ デメリット
- **メモリ消費**: ユーザー数に比例
- **拡張困難**: 複数サーバーでの共有が複雑
- **単一障害点**: セッションストレージ障害で全体停止

### よくある質問

#### Q: セッションIDが盗まれたらどうなる？
A: 攻撃者があなたになりすませる（セッションハイジャック）
**対策**: HTTPS通信、HttpOnlyクッキー

#### Q: ブラウザを閉じるとセッションはどうなる？
A: 通常は残る。明示的にログアウトが必要
**注意**: 共用PCでは必ずログアウト！

#### Q: セッションタイムアウトはなぜ必要？
A: セキュリティ確保のため
- 放置されたセッションの悪用防止
- サーバーリソースの節約

#### Q: 複数タブで同じサイトを開いたら？
A: 同じセッションを共有
- 一つのタブでログアウト → 全タブでログアウト

---

## セッションとステートの関係（まとめ）

### 🔗 セッションとステートの関係性
ここまでで「セッション」と「ステートフル/ステートレス」について学びました。  
これらの概念の関係を整理しましょう：

#### 概念の整理
- **ステート（状態）** = 「誰がログインしているか」「何をしていたか」などの **情報そのもの**
- **セッション** = その状態情報を **管理する仕組み・期間**

```
例：オンラインショッピング
┌─────────────────┬──────────────────┐
│ ステート（状態）  │ セッション（仕組み） │
├─────────────────┼──────────────────┤
│ ログイン中       │ ログインから        │
│ カートに商品3点   │ ログアウトまでの    │
│ 配送先：東京      │ 一連の期間・管理    │
│ 決済方法：クレカ   │                 │
└─────────────────┴──────────────────┘
```

#### 🏪 日常での例え
```
お店での買い物で考えると...

ステート（状態）:
- あなたが「VIP会員」であること
- 「Tシャツを3枚選んだ」こと  
- 「支払いはクレジットカード」を選択

セッション（仕組み）:
- 店員があなたを覚えている期間
- 入店からお会計までの一連の流れ
- あなたの情報を管理するシステム
```

#### ステートフル/ステートレスとセッションの関係

**ステートフル認証**
```
セッション = サーバー側で管理
├ セッションID → サーバーに送信
├ ステート（状態）→ サーバーで保存・管理
└ 利点：サーバーが全てを制御
```

**ステートレス認証** 
```
「セッション」という概念は使わない
├ JWT等のトークン → クライアントに送信
├ ステート（状態）→ トークン内に含める
└ 利点：サーバーは状態を保持しない
```

---

## ステートレスとステートフルの基礎

### ステートフル（Stateful）とは
**状態を保持**するアプローチ
- サーバーがクライアントとの **やり取りの状態** を記憶
- セッション情報をサーバー側で管理
- クライアントの識別にセッションIDを使用

### ステートレス（Stateless）とは  
**状態を保持しない**アプローチ
- サーバーは過去のやり取りを記憶しない
- 各リクエストが **完全に独立**
- 必要な情報はすべてリクエストに含める

### 比較表

| 項目 | ステートフル | ステートレス |
|------|-------------|-------------|
| **状態管理** | サーバー側で管理 | クライアント側で管理 |
| **メモリ使用** | サーバーメモリ使用 | サーバーメモリ節約 |
| **スケーラビリティ** | 拡張が困難 | 拡張が容易 |
| **障害耐性** | サーバー障害で状態喪失 | 高い耐性 |
| **通信効率** | 軽量（IDのみ） | 重い（情報全体） |
| **セキュリティ** | サーバー側で制御 | トークン管理が重要 |

### 認証における違い

#### ステートフル認証の例
```
1. ユーザーログイン → サーバーがセッション作成
2. セッションIDをクッキーで送信
3. 以降のリクエストでセッションIDを確認
4. サーバー側でセッション情報を保持
```

#### ステートレス認証の例  
```
1. ユーザーログイン → JWTトークン発行
2. トークンをクライアントが保存
3. 各リクエストでトークンを送信
4. サーバーは毎回トークンを検証（状態保持なし）
```

### 実際のWebアプリケーションでの例

#### ステートフル（セッション認証）
```
ブラウザ                    Webサーバー
   |                          |
   |--- ログイン要求 --------> |
   |                          | [セッション作成]
   |<-- セッションID(Cookie)-- |  SessionStore
   |                          |  ├ SessionID: ABC123
   |                          |  └ UserID: user001
   |                          |
   |--- API要求（+Cookie）----> |
   |                          | [セッション確認]
   |<-- レスポンス ------------ |
```

#### ステートレス（JWT認証）
```
ブラウザ                    Webサーバー
   |                          |
   |--- ログイン要求 --------> |
   |                          | [JWTトークン生成]
   |<-- JWT トークン --------- |  状態保存なし
   |                          |
   |--- API要求（+JWT）------> |
   |                          | [トークン検証のみ]
   |<-- レスポンス ------------ |
```

### メリット・デメリット

#### ステートフルのメリット
- **簡単な実装**: セッション管理ライブラリが豊富
- **細かい制御**: サーバー側で詳細な状態管理
- **即座の無効化**: セッション削除で即座にログアウト
- **軽量通信**: セッションIDのみ送信

#### ステートフルのデメリット  
- **メモリ消費**: セッション情報をサーバーで保持
- **スケーリング困難**: サーバー間でセッション共有が必要
- **単一障害点**: セッションストレージ障害で全体影響

#### ステートレスのメリット
- **高いスケーラビリティ**: サーバー追加が容易
- **障害耐性**: サーバー障害の影響が限定的  
- **分散システム向け**: マイクロサービスに適している
- **CDN活用**: エッジサーバーでの処理が可能

#### ステートレスのデメリット
- **トークンサイズ**: 情報をすべて含むため大きい
- **無効化困難**: トークンの途中無効化が複雑
- **機密情報制限**: トークンに機密情報を含められない
- **時刻同期**: トークン有効期限管理が重要

### どちらを選ぶべきか？

#### ステートフルが適している場面
- **従来のWebアプリケーション**
- **厳密なセッション管理が必要**
- **リアルタイムな状態変更が重要**
- **単一サーバーでの小規模運用**

#### ステートレスが適している場面  
- **API中心のアプリケーション**
- **マイクロサービス**
- **モバイルアプリ**
- **大規模分散システム**
- **CDNやエッジコンピューティング活用**

---

## 認証の種類

### 1. 基本認証（Basic Authentication）
**🏷️ タイプ**: ステートレス
```
Authorization: Basic base64(username:password)
```
- **メリット**: シンプルで実装が容易
- **デメリット**: パスワードがBase64エンコードのみ（暗号化されていない）
- **状態管理**: なし（毎回認証情報を送信）

### 2. セッション認証
**🏷️ タイプ**: ステートフル
```
1. ログイン → サーバーがセッションID生成
2. クッキーにセッションID保存
3. 以降のリクエストでセッションID送信
```
- **メリット**: サーバー側でセッション管理可能、即座の無効化
- **デメリット**: サーバー側でセッション情報保存が必要、スケーリング困難
- **状態管理**: サーバー側でセッション情報を保持

### 3. JWT（JSON Web Token）
**🏷️ タイプ**: ステートレス
```
Header.Payload.Signature
```
- **メリット**: ステートレス、分散システムに適している、スケーラブル
- **デメリット**: トークンサイズが大きい、リボークが困難
- **状態管理**: なし（トークン自体に情報を含める）

### 4. OAuth 2.0
**🏷️ タイプ**: ステートレス（トークンベース）
```
1. 認可サーバーにリダイレクト
2. ユーザー認証・同意
3. 認可コード取得
4. アクセストークン交換
```
- **メリット**: 第三者認証、スコープ制御、標準プロトコル
- **デメリット**: 実装が複雑、トークン管理が重要
- **状態管理**: アクセストークンに情報を含める（ステートレス）

### 5. AWS Cognito
**🏷️ タイプ**: ステートレス（JWT + OAuth2ベース）
```
1. User Pool での認証
2. JWT トークン発行
3. トークンでAPIアクセス
```
- **メリット**: マネージドサービス、MFA内蔵、スケーラブル
- **デメリット**: AWS依存、カスタマイズ制限
- **状態管理**: JWTトークンベース（ステートレス）

### 認証方式とステート管理の関係

| 認証方式 | タイプ | 状態保存場所 | スケーラビリティ |
|---------|--------|-------------|----------------|
| **基本認証** | ステートレス | なし | 高 |
| **セッション認証** | ステートフル | サーバー | 低 |
| **JWT認証** | ステートレス | クライアント | 高 |
| **OAuth 2.0** | ステートレス | クライアント | 高 |
| **AWS Cognito** | ステートレス | クライアント | 高 |

---

## 実装方法

### セッション認証の実装例
```javascript
// ログイン処理
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  // パスワード検証
  if (validateUser(username, password)) {
    req.session.userId = user.id;
    res.json({ success: true });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});

// 認証チェックミドルウェア
function requireAuth(req, res, next) {
  if (req.session.userId) {
    next();
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
}
```

### JWT認証の実装例
```javascript
// JWTトークン生成
const jwt = require('jsonwebtoken');

app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  if (validateUser(username, password)) {
    const token = jwt.sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
    res.json({ token });
  }
});

// JWT認証ミドルウェア
function verifyToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
}
```

---

## セキュリティ脆弱性

### 1. 弱いパスワード
- **問題**: 推測しやすいパスワード
- **対策**: パスワード強度要件、パスワードポリシー

### 2. セッションハイジャック
- **問題**: セッションIDが盗まれる
- **対策**: HTTPS使用、セッションIDの定期更新

### 3. CSRF（Cross-Site Request Forgery）
- **問題**: 悪意のあるサイトから不正リクエスト
- **対策**: CSRFトークン、SameSite Cookie

### 4. XSS（Cross-Site Scripting）
- **問題**: 悪意のあるスクリプト注入
- **対策**: 入力値検証、出力エスケープ

### 5. ブルートフォース攻撃
- **問題**: パスワード総当たり攻撃
- **対策**: レート制限、アカウントロック

---

## ベストプラクティス

### 1. パスワード管理
- **ハッシュ化**: bcrypt、scrypt、Argon2使用
- **ソルト**: レインボーテーブル攻撃対策
- **最小長**: 8文字以上推奨

### 2. セッション管理
- **HTTPSのみ**: Secure Cookie属性
- **SameSite**: CSRF攻撃対策
- **有効期限**: 適切なタイムアウト設定

### 3. 多要素認証（MFA）
- **SMS認証**: 電話番号による認証
- **TOTP**: Time-based One-Time Password
- **ハードウェアキー**: FIDO2/WebAuthn

### 4. 監査とログ
- **ログイン試行**: 成功・失敗の記録
- **異常検知**: 不審なアクセスパターン
- **定期監査**: セキュリティ状況の確認

---

## 実演デモ

### デモ内容
1. **基本認証**: 簡単なログインフォーム
2. **セッション認証**: Cookie使用したセッション管理
3. **JWT認証**: トークンベース認証
4. **脆弱性例**: 実際の攻撃例とその対策

### 実行方法
```bash
# デモアプリケーション起動
cd demo
python3 -m http.server 8000
# または
npx serve .
```

ブラウザで `http://localhost:8000` にアクセス

---

## まとめ

### 重要なポイント
1. **認証 ≠ 認可**: 役割の違いを理解
2. **適切な認証方式選択**: 要件に応じた選択
3. **セキュリティ第一**: 脆弱性対策を忘れずに
4. **ユーザビリティ**: セキュリティと使いやすさのバランス

### 次のステップ
- 実際のプロジェクトで実装
- セキュリティテストの実施
- 最新の脅威情報の収集
- 継続的なセキュリティ改善

---

## 参考資料
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [JWT.io](https://jwt.io/)
- [OAuth 2.0 RFC](https://tools.ietf.org/html/rfc6749)
- [WebAuthn Guide](https://webauthn.guide/)